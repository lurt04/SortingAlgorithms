#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <string>

const int LISTSIZE		= 10000;			// lijst grootte


//
// algemene 'lijst' class:
//
class List
{
public:
	int m_size;
	int *m_data;
	std::string m_name;

	List(int size, std::string name)
	{
		m_size = size;
		m_data = new int[size];
		m_size = size;
		m_name = name;
	}

	List(List& src)
	{
		m_size = src.m_size;
		m_data = new int[m_size];
		m_name = src.m_name;
		for (int i=0; i<m_size; i++)
		{
			m_data[i] = src.m_data[i];
		}
	}

	List& operator = (const List &src)
	{
		m_size = src.m_size;
		m_data = new int[src.m_size];
		m_name = src.m_name;
		for (int i=0; i<m_size; i++)
		{
			m_data[i] = src.m_data[i];
		}
		return *this;
	}

	virtual ~List()
	{
		if (m_data != nullptr)
		{
			delete m_data;
			m_data = nullptr;
		}
	}


	// laat de inhoud van de lijst zien
	void show()
	{
		const int N_PER_LINE = 25;
		const int MAX_LINES = 2;

		for (int i=0; i<m_size; i++)
		{
			printf ("%05d ",m_data[i]);

			if ((i % N_PER_LINE) == (N_PER_LINE-1))
			{
				// elke 'N' elementen komt er een newline
				printf("\n");

				// we willen het leesbaar houden:
				// dus als er teveel lines uitgevoerd dreigen te worden skippen we een gedeelte
				if ((i / N_PER_LINE) == (MAX_LINES-1))
				{
					printf ("..... ..... ");
					i = m_size - (N_PER_LINE/2);
				}
			}
		}

		// aan 't einde van de lijst een newline
		printf("\n");
	}

	// verwissel 2 elementen in de lijst
	void swapElement(int a, int b)
	{
		int temp = m_data[a];
		m_data[a] = m_data[b];
		m_data[b] = temp;
	}

	// keer volgorde van alle elementen in de lijst om
	void reverseList()
	{
		for (int i=0; i<(m_size/2); i++)
		{
			swapElement(i,(m_size-1-i));
		}
	}
};

//
// generieke 'Sort' class
//
class Sort
{
public:
	std::string m_name;

	Sort(std::string name)
	{
		m_name = name;
	}

	virtual void sort(List& l) = 0;
};

//
// BubbleSort class
//
class BubbleSort : public Sort
{
public:
	BubbleSort()
		: Sort("BUBBLESORT")
	{
	}

	void sort(List& list) override
	{
		for (int i=0; i<list.m_size-1; i++)
		{
			for (int j=0; j<list.m_size-i-1; j++)
			{
				if (list.m_data[j] > list.m_data[j+1])
				{
					list.swapElement(j,j+1);
				}
			}
		}
	}
};


//
// InsertionSort class
//
class InsertionSort : public Sort
{
public:
	InsertionSort()
		: Sort("INSERTIONSORT")
	{
	}

	void sort(List& list) override
	{
		for (int i=1; i<list.m_size; i++)
		{
			for (int k=i; (k>0) && (list.m_data[k] < list.m_data[k-1]); k--)
			{
				list.swapElement(k,k-1);
			}
		}
	}
};

//
// Quicksort class
//
class QuickSort : public Sort
{
	// variabelen om bij te houden hoe 'diep' de recursie is gegaan
	int m_recursion_ctr;
	int m_recursion_max;

	// default quickSort algorithme
	void quickSort(List& list, int low, int high)
	{
		int i = low;
		int j = high;
		int pivot = list.m_data[(i+j)/2];

		m_recursion_ctr++;
		if (m_recursion_ctr > m_recursion_max)
		{
			m_recursion_max = m_recursion_ctr;
		}

		while (i <= j)
		{
			while (list.m_data[i] < pivot)
			{
				i++;
			}

			while (list.m_data[j] > pivot)
			{
				j--;
			}

			if (i <= j)
			{
				list.swapElement(i,j);
				i++;
				j--;
			}
		}

		if (j > low)
		{
			quickSort(list, low, j);
		}
		if (i < high)
		{
			quickSort(list, i, high);
		}

		m_recursion_ctr--;
	}

public:
	QuickSort()
		: Sort("QUICKSORT")
	{
	}

	void sort(List& list) override
	{
		// reset de recursie diepte meting:
		m_recursion_ctr = 0;
		m_recursion_max = 0;

		// start het algorithme:
		quickSort(list, 0, list.m_size);
	}

	// geef de max. recursie-diepte (sinds de laatste oproep van sort() )
	int getMaxRecursionDepth()
	{
		return m_recursion_max;
	}
};



//
// Random lijst:
//
class RandomList : public List
{
public:
	RandomList(int size, std::string name)
		: List(size, name)
	{
		const int MAXVAL = 100000;

		for (int i=0; i<m_size; i++)
		{
			m_data[i] = rand() % MAXVAL;
		}
	}
};

//
// omgekeerde random lijst
//
class ReverseList : public RandomList
{
public:
	ReverseList(int size, std::string name)
		: RandomList(size, name)
	{
		BubbleSort().sort(*this);
		reverseList();
	}
};


//
// 'Nearly sorted' lijst:
//
// n.b.: het is onduidelijk in de opdracht wat 'nearly' sorted exact betekent :-(
//
//  zie ook:: http://homepage.cs.uiowa.edu/~sriram/21/spring06/homework2Solution.html
//  The "almost sorted" array is generated by starting with an int array of size n containing the sequence 0, 1, 2, ..., n-1 and perturbing it slightly. To perturb the array, pick at random 10 pairs of indices (in the range 0 through n-1) and for each pair of indices (i, j), swap the elements in slots i and j.
//
class NearlySortedList : public List
{
public:
	NearlySortedList(int size, std::string name)
		: List(size, name)
	{
		const int K = 10;

		for (int i=0; i<m_size; i++)
		{
			m_data[i] = i;
		}

		for (int k=0; k<K; k++)
		{
			int i = rand() % m_size;
			int j = rand() % m_size;

			swapElement(i,j);
		}
	}
};

//
// Tester class
//
class Tester
{
private:
	// variabelen voor tijdmeting
	struct timeval m_t_begin, m_t_end;

	// de Tester heeft verschillende sorting algorithms:
	BubbleSort m_bubblesort;
	InsertionSort m_insertionsort;
	QuickSort m_quicksort;

	// start tijdmeting
	void startTimer()
	{
	    gettimeofday(&m_t_begin, 0);
	}

	// stop tijdmeting en geef de tijdsduur in ms terug
	double stopTimer()
	{
	    gettimeofday(&m_t_end, 0);
	    long seconds = m_t_end.tv_sec - m_t_begin.tv_sec;
	    long micros = ((seconds * 1000000) + m_t_end.tv_usec - m_t_begin.tv_usec);

	    return micros / 1000.0;
	}

	// voer e e n test stap uit (met een gegeven lijst + gegeven sorteerder)
	void testStep(List &list, Sort &sorter)
	{
		printf ("==================================================================================================================================================\n");

		double t_ms;

		printf ("%s ongesorteerd:\n",list.m_name.c_str());
		list.show();
		startTimer();
		sorter.sort(list);
		t_ms = stopTimer();
		printf ("%s %s gesorteerd in %f ms:\n",list.m_name.c_str(),sorter.m_name.c_str(),t_ms);
		list.show();
	}

public:
	Tester()
	{
	}

	// voer alle sorteringen uit met gegeven lijst:
	void doTest(List &list)
	{
		List tmp1(list);
		testStep(tmp1, m_bubblesort);

		List tmp2(list);
		testStep(tmp2, m_insertionsort);

		List tmp3(list);
		testStep(tmp3, m_quicksort);
		printf ("(max recursie diepte = %d)\n",m_quicksort.getMaxRecursionDepth());
	}

};


//
// hoofdprogramma
//
int main(int argc, char *argv[])
{
	// initialiseer de random generator
	//srand(time(NULL));

	// e e n tester object om de tests uit te voeren
	Tester tester;

	//
	// LIJST1 = random lijst
	//
	RandomList list1(LISTSIZE,"lijst1");
	tester.doTest(list1);

	//
	// LIJST2 = omgekeerd random lijst
	//
	ReverseList list2(LISTSIZE, "lijst2");
	tester.doTest(list2);

	//
	// LIJST3 = 'nearly' sorted lijst:
	//
	NearlySortedList list3(LISTSIZE,"lijst3");
	tester.doTest(list3);

	return 0;
}
